// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Ochess from "ochess/./ochess.bs.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_string from "bs-platform/lib/es6/caml_string.js";
import * as Js_primitive from "bs-platform/lib/es6/js_primitive.js";

function home_rank(param) {
  if (param) {
    return 0;
  } else {
    return 7;
  }
}

function promotion_rank(param) {
  if (param) {
    return 7;
  } else {
    return 0;
  }
}

function pre_promotion_rank(param) {
  if (param) {
    return 6;
  } else {
    return 1;
  }
}

function coordinate_pairs(turn, param) {
  if (typeof param === "number") {
    if (param === 0) {
      return /* tuple */[
              /* tuple */[
                4,
                turn ? 0 : 7
              ],
              /* tuple */[
                6,
                turn ? 0 : 7
              ]
            ];
    } else {
      return /* tuple */[
              /* tuple */[
                4,
                turn ? 0 : 7
              ],
              /* tuple */[
                2,
                turn ? 0 : 7
              ]
            ];
    }
  } else if (param.tag) {
    return /* tuple */[
            /* tuple */[
              param[1],
              turn ? 6 : 1
            ],
            /* tuple */[
              param[2],
              turn ? 7 : 0
            ]
          ];
  } else {
    return /* tuple */[
            /* tuple */[
              param[0],
              param[1]
            ],
            /* tuple */[
              param[2],
              param[3]
            ]
          ];
  }
}

function string_of_piece_type(param) {
  switch (param) {
    case 0 : 
        return "king";
    case 1 : 
        return "queen";
    case 2 : 
        return "rook";
    case 3 : 
        return "bishop";
    case 4 : 
        return "knight";
    case 5 : 
        return "pawn";
    
  }
}

function string_of_color(param) {
  if (param) {
    return "white";
  } else {
    return "black";
  }
}

function make_move$prime(position, move) {
  return Ochess.make_move(position, move, 0);
}

function char_of_file(file) {
  return Caml_string.get("abcdefgh", file);
}

function char_of_rank(rank) {
  return Caml_string.get("12345678", rank);
}

function check_or_checkmate(position, move) {
  var position$prime = Ochess.make_move(position, move, 0);
  var checked = Ochess.king_checked(position$prime, position$prime[/* turn */1]);
  if (checked) {
    var match = Ochess.legal_moves(position$prime);
    if (match) {
      return /* Check */0;
    } else {
      return /* Checkmate */1;
    }
  } else {
    return /* No_check */2;
  }
}

function long_move(position, move) {
  if (typeof move === "number") {
    if (move === 0) {
      return /* Ochess_move */Block.__(2, [/* Kingside_castle */0]);
    } else {
      return /* Ochess_move */Block.__(2, [/* Queenside_castle */1]);
    }
  } else if (move.tag) {
    var t_file = move[2];
    var s_file = move[1];
    var match = position[/* turn */1];
    var t_rank = match ? 7 : 0;
    return /* Pawn_move */Block.__(1, [
              s_file,
              /* tuple */[
                t_file,
                t_rank
              ],
              s_file !== t_file,
              move[0]
            ]);
  } else {
    var t_rank$1 = move[3];
    var t_file$1 = move[2];
    var s_rank = move[1];
    var s_file$1 = move[0];
    var match$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(position[/* ar */0], s_file$1), s_rank);
    if (match$1) {
      var p_type = match$1[0][0];
      if (p_type >= 5) {
        return /* Pawn_move */Block.__(1, [
                  s_file$1,
                  /* tuple */[
                    t_file$1,
                    t_rank$1
                  ],
                  s_file$1 !== t_file$1,
                  undefined
                ]);
      } else {
        var match$2 = Caml_array.caml_array_get(Caml_array.caml_array_get(position[/* ar */0], t_file$1), t_rank$1);
        var capture = match$2 ? true : false;
        return /* Piece_move */Block.__(0, [
                  p_type,
                  /* tuple */[
                    s_file$1,
                    s_rank
                  ],
                  /* tuple */[
                    t_file$1,
                    t_rank$1
                  ],
                  capture
                ]);
      }
    } else {
      throw Ochess.Illegal_move;
    }
  }
}

function unify(value, hint) {
  if (hint !== undefined && !Caml_obj.caml_equal(value, Js_primitive.valFromOption(hint))) {
    return false;
  } else {
    return true;
  }
}

function unify_move(short_move, long_move) {
  switch (long_move.tag | 0) {
    case 0 : 
        var long_source = long_move[1];
        if (Caml_obj.caml_equal(short_move[3], long_move[2]) && short_move[0] === long_move[0] && unify(long_source[0], short_move[1])) {
          return unify(long_source[1], short_move[2]);
        } else {
          return false;
        }
    case 1 : 
    case 2 : 
        return false;
    
  }
}

function unique(move_list, short_move) {
  return List.length(List.filter((function (param) {
                      return unify_move(short_move, param);
                    }))(move_list)) === 1;
}

function short_move_of_long_move(move_list, long_move) {
  switch (long_move.tag | 0) {
    case 0 : 
        var capture = long_move[3];
        var target = long_move[2];
        var match = long_move[1];
        var s_rank = match[1];
        var s_file = match[0];
        var p_type = long_move[0];
        var qg7 = /* tuple */[
          p_type,
          undefined,
          undefined,
          target,
          capture
        ];
        if (unique(move_list, qg7)) {
          return qg7;
        } else {
          var qhg7_001 = s_file;
          var qhg7 = /* tuple */[
            p_type,
            qhg7_001,
            undefined,
            target,
            capture
          ];
          if (unique(move_list, qhg7)) {
            return qhg7;
          } else {
            var q8g7_002 = s_rank;
            var q8g7 = /* tuple */[
              p_type,
              undefined,
              q8g7_002,
              target,
              capture
            ];
            if (unique(move_list, q8g7)) {
              return q8g7;
            } else {
              return /* tuple */[
                      p_type,
                      s_file,
                      s_rank,
                      target,
                      capture
                    ];
            }
          }
        }
    case 1 : 
    case 2 : 
        return undefined;
    
  }
}

function san_of_move$prime(position, move_list, move) {
  var long_move$1 = long_move(position, move);
  var check = check_or_checkmate(position, move);
  var short_move_option = short_move_of_long_move(move_list, long_move$1);
  var san;
  if (short_move_option !== undefined) {
    var match = short_move_option;
    var match$1 = match[3];
    var rank_hint = match[2];
    var file_hint = match[1];
    san = Curry._6(Printf.sprintf(/* Format */[
              /* Char */Block.__(0, [/* String */Block.__(2, [
                      /* No_padding */0,
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Char */Block.__(0, [/* Char */Block.__(0, [/* End_of_format */0])])
                            ])
                        ])
                    ])]),
              "%c%s%s%s%c%c"
            ]), Ochess.char_of_piece_type(match[0]), file_hint !== undefined ? Curry._1(Printf.sprintf(/* Format */[
                    /* Char */Block.__(0, [/* End_of_format */0]),
                    "%c"
                  ]), Caml_string.get("abcdefgh", file_hint)) : "", rank_hint !== undefined ? Curry._1(Printf.sprintf(/* Format */[
                    /* Char */Block.__(0, [/* End_of_format */0]),
                    "%c"
                  ]), Caml_string.get("12345678", rank_hint)) : "", match[4] ? "x" : "", Caml_string.get("abcdefgh", match$1[0]), Caml_string.get("12345678", match$1[1]));
  } else {
    switch (long_move$1.tag | 0) {
      case 0 : 
          throw Ochess.Illegal_move;
      case 1 : 
          var promotion = long_move$1[3];
          var match$2 = long_move$1[1];
          san = Curry._4(Printf.sprintf(/* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char */Block.__(0, [/* Char */Block.__(0, [/* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])])])
                      ]),
                    "%s%c%c%s"
                  ]), long_move$1[2] ? Curry._1(Printf.sprintf(/* Format */[
                          /* Char */Block.__(0, [/* Char_literal */Block.__(12, [
                                  /* "x" */120,
                                  /* End_of_format */0
                                ])]),
                          "%cx"
                        ]), Caml_string.get("abcdefgh", long_move$1[0])) : "", Caml_string.get("abcdefgh", match$2[0]), Caml_string.get("12345678", match$2[1]), promotion !== undefined ? Curry._1(Printf.sprintf(/* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "=" */61,
                              /* Char */Block.__(0, [/* End_of_format */0])
                            ]),
                          "=%c"
                        ]), Ochess.char_of_piece_type(promotion)) : "");
          break;
      case 2 : 
          var match$3 = long_move$1[0];
          if (typeof match$3 === "number") {
            san = match$3 !== 0 ? "O-O-O" : "O-O";
          } else {
            throw Ochess.Illegal_move;
          }
          break;
      
    }
  }
  var tmp;
  switch (check) {
    case 0 : 
        tmp = "+";
        break;
    case 1 : 
        tmp = "#";
        break;
    case 2 : 
        tmp = "";
        break;
    
  }
  return san + tmp;
}

function moves_assoc_list(position, moves) {
  var long_moves = List.map((function (param) {
          return long_move(position, param);
        }), moves);
  var san_moves = List.map((function (param) {
          return san_of_move$prime(position, long_moves, param);
        }), moves);
  return List.combine(moves, san_moves);
}

function legal_moves_with_san(position) {
  return moves_assoc_list(position, Ochess.legal_moves(position));
}

function san_of_move(position, move) {
  var move_list = List.map((function (param) {
          return long_move(position, param);
        }), Ochess.legal_moves(position));
  return san_of_move$prime(position, move_list, move);
}

var split_on_char = Ochess.split_on_char;

var identical_positions = Ochess.identical_positions;

var draw_by_repetition_aux = Ochess.draw_by_repetition_aux;

var draw_by_repetition = Ochess.draw_by_repetition;

var draw_by_lack_of_progress = Ochess.draw_by_lack_of_progress;

var draw = Ochess.draw;

var opposite_color = Ochess.opposite_color;

var color_sign = Ochess.color_sign;

var piece_chars = Ochess.piece_chars;

var char_of_piece_type = Ochess.char_of_piece_type;

var rassoc = Ochess.rassoc;

var piece_type_of_char = Ochess.piece_type_of_char;

var int_of_letter = Ochess.int_of_letter;

var letter_of_int = Ochess.letter_of_int;

var print_board = Ochess.print_board;

var print_position = Ochess.print_position;

var init_position = Ochess.init_position;

var within_range = Ochess.within_range;

var within_range2 = Ochess.within_range2;

var copy_matrix = Ochess.copy_matrix;

var no_k_castle = Ochess.no_k_castle;

var no_q_castle = Ochess.no_q_castle;

var Illegal_move = Ochess.Illegal_move;

var make_move = Ochess.make_move;

var knight = Ochess.knight;

var rook = Ochess.rook;

var bishop = Ochess.bishop;

var queen = Ochess.queen;

var pawn_white_mv = Ochess.pawn_white_mv;

var pawn_black_mv = Ochess.pawn_black_mv;

var pawn_white_cap = Ochess.pawn_white_cap;

var pawn_black_cap = Ochess.pawn_black_cap;

var add = Ochess.add;

var explore_direction = Ochess.explore_direction;

var explore_directions = Ochess.explore_directions;

var checked_direction = Ochess.checked_direction;

var checked_directions = Ochess.checked_directions;

var checked = Ochess.checked;

var find_king = Ochess.find_king;

var king_checked = Ochess.king_checked;

var empty_segment = Ochess.empty_segment;

var check_castle = Ochess.check_castle;

var castle_moves = Ochess.castle_moves;

var possible_field_simple_moves = Ochess.possible_field_simple_moves;

var possible_moves = Ochess.possible_moves;

var board_center = Ochess.board_center;

var mirror_y = Ochess.mirror_y;

var piece_value = Ochess.piece_value;

var field_value = Ochess.field_value;

var win = Ochess.win;

var delta = Ochess.delta;

var Interrupt = Ochess.Interrupt;

var deadline = Ochess.deadline;

var check_timer = Ochess.check_timer;

var set_timer = Ochess.set_timer;

var del_timer = Ochess.del_timer;

var Illegal_position = Ochess.Illegal_position;

var alpha_beta = Ochess.alpha_beta;

var alpha_beta_search = Ochess.alpha_beta_search;

var legal_moves = Ochess.legal_moves;

var max_depth = Ochess.max_depth;

var alpha_beta_deepening = Ochess.alpha_beta_deepening;

var previous = Ochess.previous;

var print_move = Ochess.print_move;

var is_digit = Ochess.is_digit;

var int_of_char = Ochess.int_of_char;

var parse_move_string = Ochess.parse_move_string;

var parse_move = Ochess.parse_move;

var game_status = Ochess.game_status;

var best_move = Ochess.best_move;

var init_rem_time = Ochess.init_rem_time;

var thinking_interval = Ochess.thinking_interval;

var update_remaining = Ochess.update_remaining;

var parse_time = Ochess.parse_time;

var flush = Ochess.flush;

var parse_level = Ochess.parse_level;

var main = Ochess.main;

export {
  split_on_char ,
  identical_positions ,
  draw_by_repetition_aux ,
  draw_by_repetition ,
  draw_by_lack_of_progress ,
  draw ,
  opposite_color ,
  color_sign ,
  piece_chars ,
  char_of_piece_type ,
  rassoc ,
  piece_type_of_char ,
  int_of_letter ,
  letter_of_int ,
  print_board ,
  print_position ,
  init_position ,
  within_range ,
  within_range2 ,
  copy_matrix ,
  no_k_castle ,
  no_q_castle ,
  Illegal_move ,
  make_move ,
  knight ,
  rook ,
  bishop ,
  queen ,
  pawn_white_mv ,
  pawn_black_mv ,
  pawn_white_cap ,
  pawn_black_cap ,
  add ,
  explore_direction ,
  explore_directions ,
  checked_direction ,
  checked_directions ,
  checked ,
  find_king ,
  king_checked ,
  empty_segment ,
  check_castle ,
  castle_moves ,
  possible_field_simple_moves ,
  possible_moves ,
  board_center ,
  mirror_y ,
  piece_value ,
  field_value ,
  win ,
  delta ,
  Interrupt ,
  deadline ,
  check_timer ,
  set_timer ,
  del_timer ,
  Illegal_position ,
  alpha_beta ,
  alpha_beta_search ,
  legal_moves ,
  max_depth ,
  alpha_beta_deepening ,
  previous ,
  print_move ,
  is_digit ,
  int_of_char ,
  parse_move_string ,
  parse_move ,
  game_status ,
  best_move ,
  init_rem_time ,
  thinking_interval ,
  update_remaining ,
  parse_time ,
  flush ,
  parse_level ,
  main ,
  home_rank ,
  promotion_rank ,
  pre_promotion_rank ,
  coordinate_pairs ,
  string_of_piece_type ,
  string_of_color ,
  make_move$prime ,
  char_of_file ,
  char_of_rank ,
  check_or_checkmate ,
  long_move ,
  unify ,
  unify_move ,
  unique ,
  short_move_of_long_move ,
  san_of_move$prime ,
  moves_assoc_list ,
  legal_moves_with_san ,
  san_of_move ,
  
}
/* Ochess Not a pure module */
