// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as Sys from "bs-platform/lib/es6/sys.js";
import * as Char from "bs-platform/lib/es6/char.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Printf from "bs-platform/lib/es6/printf.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_sys from "bs-platform/lib/es6/caml_sys.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_string from "bs-platform/lib/es6/caml_string.js";
import * as Caml_primitive from "bs-platform/lib/es6/caml_primitive.js";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function split_on_char(sep, s) {
  var r = /* [] */0;
  var j = s.length;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    if (Caml_string.get(s, i) === sep) {
      r = /* :: */[
        $$String.sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        r
      ];
      j = i;
    }
    
  }
  return /* :: */[
          $$String.sub(s, 0, j),
          r
        ];
}

function identical_positions(x, y) {
  if (x[/* eval */10] === y[/* eval */10] && x[/* turn */1] === y[/* turn */1] && Caml_obj.caml_equal(x[/* cas_w */2], y[/* cas_w */2]) && Caml_obj.caml_equal(x[/* cas_b */3], y[/* cas_b */3]) && Caml_obj.caml_equal(x[/* en_passant */4], y[/* en_passant */4])) {
    return Caml_obj.caml_equal(x[/* ar */0], y[/* ar */0]);
  } else {
    return false;
  }
}

function draw_by_repetition_aux(pos, _p, _n) {
  while(true) {
    var n = _n;
    var p = _p;
    if (n <= 0) {
      return true;
    } else if ((n << 1) > p[/* irr_change */6]) {
      return false;
    } else {
      var match = p[/* prev */5];
      if (match !== undefined) {
        var pp = match;
        if (identical_positions(pos, pp)) {
          _n = n - 1 | 0;
          _p = pp;
          continue ;
        } else {
          _p = pp;
          continue ;
        }
      } else {
        return false;
      }
    }
  };
}

function draw_by_repetition(pos) {
  return draw_by_repetition_aux(pos, pos, 2);
}

function draw_by_lack_of_progress(pos) {
  return pos[/* irr_change */6] >= 100;
}

function draw(pos) {
  if (pos[/* irr_change */6] >= 100) {
    return true;
  } else {
    return draw_by_repetition_aux(pos, pos, 2);
  }
}

function opposite_color(param) {
  if (param) {
    return /* Black */0;
  } else {
    return /* White */1;
  }
}

function color_sign(param) {
  if (param) {
    return 1;
  } else {
    return -1;
  }
}

var piece_chars = /* :: */[
  /* tuple */[
    /* King */0,
    /* "K" */75
  ],
  /* :: */[
    /* tuple */[
      /* Queen */1,
      /* "Q" */81
    ],
    /* :: */[
      /* tuple */[
        /* Rook */2,
        /* "R" */82
      ],
      /* :: */[
        /* tuple */[
          /* Bishop */3,
          /* "B" */66
        ],
        /* :: */[
          /* tuple */[
            /* Knight */4,
            /* "N" */78
          ],
          /* :: */[
            /* tuple */[
              /* Pawn */5,
              /* "P" */80
            ],
            /* [] */0
          ]
        ]
      ]
    ]
  ]
];

function char_of_piece_type(pt) {
  return List.assoc(pt, piece_chars);
}

function rassoc(x, _lst) {
  while(true) {
    var lst = _lst;
    if (lst) {
      var match = lst[0];
      if (Caml_obj.caml_equal(x, match[1])) {
        return match[0];
      } else {
        _lst = lst[1];
        continue ;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function piece_type_of_char(c) {
  return rassoc(Char.uppercase(c), piece_chars);
}

function int_of_letter(x) {
  var x$1 = Char.lowercase(x);
  if (/* "a" */97 <= x$1 && x$1 <= /* "h" */104) {
    return x$1 - /* "a" */97 | 0;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function letter_of_int(x) {
  return Caml_string.get("abcdefgh", x);
}

function print_board(ar) {
  var separator = "\n   +----+----+----+----+----+----+----+----+\n";
  Pervasives.print_string(separator);
  for(var j = 7; j >= 0; --j){
    Curry._1(Printf.printf(/* Format */[
              /* Char_literal */Block.__(12, [
                  /* " " */32,
                  /* Int */Block.__(4, [
                      /* Int_d */0,
                      /* No_padding */0,
                      /* No_precision */0,
                      /* String_literal */Block.__(11, [
                          " |",
                          /* End_of_format */0
                        ])
                    ])
                ]),
              " %d |"
            ]), j + 1 | 0);
    for(var i = 0; i <= 7; ++i){
      var match = Caml_array.caml_array_get(Caml_array.caml_array_get(ar, i), j);
      if (match) {
        var match$1 = match[0];
        Curry._2(Printf.printf(/* Format */[
                  /* Char_literal */Block.__(12, [
                      /* " " */32,
                      /* Char */Block.__(0, [/* Char */Block.__(0, [/* String_literal */Block.__(11, [
                                  " |",
                                  /* End_of_format */0
                                ])])])
                    ]),
                  " %c%c |"
                ]), match$1[1] === /* White */1 ? /* " " */32 : /* "*" */42, List.assoc(match$1[0], piece_chars));
      } else {
        Pervasives.print_string("    |");
      }
    }
    Pervasives.print_string(separator);
  }
  return Pervasives.print_string("\n      a    b    c    d    e    f    g    h\n");
}

function print_position(p) {
  print_board(p[/* ar */0]);
  var match = p[/* turn */1];
  if (match) {
    return Printf.printf(/* Format */[
                /* String_literal */Block.__(11, [
                    "\n White's turn to move\n\n",
                    /* End_of_format */0
                  ]),
                "\n White's turn to move\n\n"
              ]);
  } else {
    return Printf.printf(/* Format */[
                /* String_literal */Block.__(11, [
                    "\n Black's turn to move\n\n",
                    /* End_of_format */0
                  ]),
                "\n Black's turn to move\n\n"
              ]);
  }
}

var init_array = $$Array.make_matrix(8, 8, /* Empty */0);

function put(i, j, pt) {
  Caml_array.caml_array_set(Caml_array.caml_array_get(init_array, i), j, /* Piece */[/* tuple */[
          pt,
          /* White */1
        ]]);
  return Caml_array.caml_array_set(Caml_array.caml_array_get(init_array, i), 7 - j | 0, /* Piece */[/* tuple */[
                pt,
                /* Black */0
              ]]);
}

for(var i = 0; i <= 7; ++i){
  put(i, 1, /* Pawn */5);
}

put(0, 0, /* Rook */2);

put(7, 0, /* Rook */2);

put(1, 0, /* Knight */4);

put(6, 0, /* Knight */4);

put(2, 0, /* Bishop */3);

put(5, 0, /* Bishop */3);

put(3, 0, /* Queen */1);

put(4, 0, /* King */0);

var init_position_002 = /* cas_w : tuple */[
  true,
  true
];

var init_position_003 = /* cas_b : tuple */[
  true,
  true
];

var init_position_007 = /* king_w : tuple */[
  4,
  0
];

var init_position_008 = /* king_b : tuple */[
  4,
  7
];

var init_position = /* record */[
  /* ar */init_array,
  /* turn : White */1,
  init_position_002,
  init_position_003,
  /* en_passant */undefined,
  /* prev */undefined,
  /* irr_change */0,
  init_position_007,
  init_position_008,
  /* number */0,
  /* eval */0
];

function within_range(i) {
  if (i >= 0) {
    return i <= 7;
  } else {
    return false;
  }
}

function within_range2(param) {
  if (within_range(param[0])) {
    return within_range(param[1]);
  } else {
    return false;
  }
}

function copy_matrix(m) {
  var tmp = $$Array.copy(m);
  $$Array.iteri((function (i, elt) {
          return Caml_array.caml_array_set(tmp, i, $$Array.copy(elt));
        }), m);
  return tmp;
}

function no_k_castle(param) {
  return /* tuple */[
          param[0],
          false
        ];
}

function no_q_castle(param) {
  return /* tuple */[
          false,
          param[1]
        ];
}

var Illegal_move = Caml_exceptions.create("Ochess.Illegal_move");

function make_move(pos, m, del) {
  var ar2 = copy_matrix(pos[/* ar */0]);
  var mv = function (x1, y1, x2, y2) {
    Caml_array.caml_array_set(Caml_array.caml_array_get(ar2, x2), y2, Caml_array.caml_array_get(Caml_array.caml_array_get(ar2, x1), y1));
    return Caml_array.caml_array_set(Caml_array.caml_array_get(ar2, x1), y1, /* Empty */0);
  };
  var tmp_001 = /* turn */pos[/* turn */1] ? /* Black */0 : /* White */1;
  var tmp_002 = /* cas_w */pos[/* cas_w */2];
  var tmp_003 = /* cas_b */pos[/* cas_b */3];
  var tmp_005 = /* prev */pos;
  var tmp_006 = /* irr_change */pos[/* irr_change */6];
  var tmp_007 = /* king_w */pos[/* king_w */7];
  var tmp_008 = /* king_b */pos[/* king_b */8];
  var tmp_009 = /* number */pos[/* number */9] + 1 | 0;
  var tmp_010 = /* eval */(-pos[/* eval */10] | 0) + del | 0;
  var tmp = /* record */[
    /* ar */ar2,
    tmp_001,
    tmp_002,
    tmp_003,
    /* en_passant */undefined,
    tmp_005,
    tmp_006,
    tmp_007,
    tmp_008,
    tmp_009,
    tmp_010
  ];
  var t = pos[/* turn */1];
  var ic = false;
  var ret;
  if (typeof m === "number") {
    if (m === 0) {
      if (t) {
        mv(7, 0, 5, 0);
        mv(4, 0, 6, 0);
        ret = /* record */[
          /* ar */ar2,
          tmp_001,
          /* cas_w : tuple */[
            false,
            false
          ],
          tmp_003,
          /* en_passant */undefined,
          tmp_005,
          tmp_006,
          /* king_w : tuple */[
            6,
            0
          ],
          tmp_008,
          tmp_009,
          tmp_010
        ];
      } else {
        mv(7, 7, 5, 7);
        mv(4, 7, 6, 7);
        ret = /* record */[
          /* ar */ar2,
          tmp_001,
          tmp_002,
          /* cas_b : tuple */[
            false,
            false
          ],
          /* en_passant */undefined,
          tmp_005,
          tmp_006,
          tmp_007,
          /* king_b : tuple */[
            6,
            7
          ],
          tmp_009,
          tmp_010
        ];
      }
    } else if (t) {
      mv(0, 0, 3, 0);
      mv(4, 0, 2, 0);
      ret = /* record */[
        /* ar */ar2,
        tmp_001,
        /* cas_w : tuple */[
          false,
          false
        ],
        tmp_003,
        /* en_passant */undefined,
        tmp_005,
        tmp_006,
        /* king_w : tuple */[
          2,
          0
        ],
        tmp_008,
        tmp_009,
        tmp_010
      ];
    } else {
      mv(0, 7, 3, 7);
      mv(4, 7, 2, 7);
      ret = /* record */[
        /* ar */ar2,
        tmp_001,
        tmp_002,
        /* cas_b : tuple */[
          false,
          false
        ],
        /* en_passant */undefined,
        tmp_005,
        tmp_006,
        tmp_007,
        /* king_b : tuple */[
          2,
          7
        ],
        tmp_009,
        tmp_010
      ];
    }
  } else if (m.tag) {
    var x2 = m[2];
    ic = true;
    var match = t ? /* tuple */[
        6,
        7
      ] : /* tuple */[
        1,
        0
      ];
    var y2 = match[1];
    mv(m[1], match[0], x2, y2);
    Caml_array.caml_array_set(Caml_array.caml_array_get(ar2, x2), y2, /* Piece */[/* tuple */[
            m[0],
            pos[/* turn */1]
          ]]);
    ret = tmp;
  } else {
    var y2$1 = m[3];
    var x2$1 = m[2];
    var y1 = m[1];
    var x1 = m[0];
    var match$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x2$1), y2$1);
    if (match$1) {
      ic = true;
    }
    mv(x1, y1, x2$1, y2$1);
    var match$2 = Caml_array.caml_array_get(Caml_array.caml_array_get(ar2, x2$1), y2$1);
    var p;
    if (match$2) {
      p = match$2[0][0];
    } else {
      throw Illegal_move;
    }
    switch (p) {
      case 0 : 
          var match$3 = pos[/* turn */1];
          ret = match$3 ? /* record */[
              /* ar */ar2,
              tmp_001,
              /* cas_w : tuple */[
                false,
                false
              ],
              tmp_003,
              /* en_passant */undefined,
              tmp_005,
              tmp_006,
              /* king_w : tuple */[
                x2$1,
                y2$1
              ],
              tmp_008,
              tmp_009,
              tmp_010
            ] : /* record */[
              /* ar */ar2,
              tmp_001,
              tmp_002,
              /* cas_b : tuple */[
                false,
                false
              ],
              /* en_passant */undefined,
              tmp_005,
              tmp_006,
              tmp_007,
              /* king_b : tuple */[
                x2$1,
                y2$1
              ],
              tmp_009,
              tmp_010
            ];
          break;
      case 2 : 
          var match$4 = pos[/* turn */1];
          ret = match$4 ? (
              x1 !== 0 ? (
                  x1 !== 7 || y1 !== 0 ? tmp : /* record */[
                      /* ar */ar2,
                      tmp_001,
                      /* cas_w */no_k_castle(pos[/* cas_w */2]),
                      tmp_003,
                      /* en_passant */undefined,
                      tmp_005,
                      tmp_006,
                      tmp_007,
                      tmp_008,
                      tmp_009,
                      tmp_010
                    ]
                ) : (
                  y1 !== 0 ? tmp : /* record */[
                      /* ar */ar2,
                      tmp_001,
                      /* cas_w */no_q_castle(pos[/* cas_w */2]),
                      tmp_003,
                      /* en_passant */undefined,
                      tmp_005,
                      tmp_006,
                      tmp_007,
                      tmp_008,
                      tmp_009,
                      tmp_010
                    ]
                )
            ) : (
              x1 !== 0 ? (
                  x1 !== 7 || y1 !== 7 ? tmp : /* record */[
                      /* ar */ar2,
                      tmp_001,
                      tmp_002,
                      /* cas_b */no_k_castle(pos[/* cas_b */3]),
                      /* en_passant */undefined,
                      tmp_005,
                      tmp_006,
                      tmp_007,
                      tmp_008,
                      tmp_009,
                      tmp_010
                    ]
                ) : (
                  y1 !== 7 ? tmp : /* record */[
                      /* ar */ar2,
                      tmp_001,
                      tmp_002,
                      /* cas_b */no_q_castle(pos[/* cas_b */3]),
                      /* en_passant */undefined,
                      tmp_005,
                      tmp_006,
                      tmp_007,
                      tmp_008,
                      tmp_009,
                      tmp_010
                    ]
                )
            );
          break;
      case 1 : 
      case 3 : 
      case 4 : 
          ret = tmp;
          break;
      case 5 : 
          ic = true;
          var match$5 = Caml_array.caml_array_get(Caml_array.caml_array_get(ar2, x2$1), y2$1);
          var match$6 = pos[/* turn */1];
          var e2;
          if (match$5) {
            var match$7 = match$5[0];
            e2 = match$7[0] >= 5 ? (
                match$7[1] ? (
                    match$6 && x1 === x2$1 && y1 === 1 && y2$1 === 3 ? x1 : undefined
                  ) : (
                    match$6 || !(x1 === x2$1 && y1 === 6 && y2$1 === 4) ? undefined : x1
                  )
              ) : undefined;
          } else {
            e2 = undefined;
          }
          var match$8 = pos[/* en_passant */4];
          if (match$8 !== undefined) {
            var i = match$8;
            if (i === x2$1) {
              var match$9 = pos[/* turn */1];
              if (match$9) {
                if (y2$1 === 5) {
                  Caml_array.caml_array_set(Caml_array.caml_array_get(ar2, i), 4, /* Empty */0);
                }
                
              } else if (y2$1 === 2) {
                Caml_array.caml_array_set(Caml_array.caml_array_get(ar2, i), 3, /* Empty */0);
              }
              
            }
            
          }
          ret = /* record */[
            /* ar */ar2,
            tmp_001,
            tmp_002,
            tmp_003,
            /* en_passant */e2,
            tmp_005,
            tmp_006,
            tmp_007,
            tmp_008,
            tmp_009,
            tmp_010
          ];
          break;
      
    }
  }
  return /* record */[
          /* ar */ret[/* ar */0],
          /* turn */ret[/* turn */1],
          /* cas_w */ret[/* cas_w */2],
          /* cas_b */ret[/* cas_b */3],
          /* en_passant */ret[/* en_passant */4],
          /* prev */ret[/* prev */5],
          /* irr_change */ic ? 0 : pos[/* irr_change */6] + 1 | 0,
          /* king_w */ret[/* king_w */7],
          /* king_b */ret[/* king_b */8],
          /* number */ret[/* number */9],
          /* eval */ret[/* eval */10]
        ];
}

var knight = /* :: */[
  /* tuple */[
    1,
    2
  ],
  /* :: */[
    /* tuple */[
      1,
      -2
    ],
    /* :: */[
      /* tuple */[
        2,
        1
      ],
      /* :: */[
        /* tuple */[
          2,
          -1
        ],
        /* :: */[
          /* tuple */[
            -1,
            2
          ],
          /* :: */[
            /* tuple */[
              -1,
              -2
            ],
            /* :: */[
              /* tuple */[
                -2,
                1
              ],
              /* :: */[
                /* tuple */[
                  -2,
                  -1
                ],
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var rook = /* :: */[
  /* tuple */[
    -1,
    0
  ],
  /* :: */[
    /* tuple */[
      0,
      -1
    ],
    /* :: */[
      /* tuple */[
        0,
        1
      ],
      /* :: */[
        /* tuple */[
          1,
          0
        ],
        /* [] */0
      ]
    ]
  ]
];

var bishop = /* :: */[
  /* tuple */[
    -1,
    -1
  ],
  /* :: */[
    /* tuple */[
      -1,
      1
    ],
    /* :: */[
      /* tuple */[
        1,
        -1
      ],
      /* :: */[
        /* tuple */[
          1,
          1
        ],
        /* [] */0
      ]
    ]
  ]
];

var queen = Pervasives.$at(bishop, rook);

var pawn_white_cap = /* :: */[
  /* tuple */[
    -1,
    1
  ],
  /* :: */[
    /* tuple */[
      1,
      1
    ],
    /* [] */0
  ]
];

var pawn_black_cap = /* :: */[
  /* tuple */[
    -1,
    -1
  ],
  /* :: */[
    /* tuple */[
      1,
      -1
    ],
    /* [] */0
  ]
];

function add(param, param$1) {
  return /* tuple */[
          param[0] + param$1[0] | 0,
          param[1] + param$1[1] | 0
        ];
}

function explore_direction(pos, x_init, y_init, _x, _y, dx, dy, _num, _acc) {
  while(true) {
    var acc = _acc;
    var num = _num;
    var y = _y;
    var x = _x;
    if (num < 1) {
      return acc;
    } else {
      var match = add(/* tuple */[
            x,
            y
          ], /* tuple */[
            dx,
            dy
          ]);
      var y2 = match[1];
      var x2 = match[0];
      if (within_range2(/* tuple */[
              x2,
              y2
            ])) {
        var match$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x2), y2);
        if (match$1) {
          if (match$1[0][1] !== pos[/* turn */1]) {
            return /* :: */[
                    /* Move */Block.__(0, [
                        x_init,
                        y_init,
                        x2,
                        y2
                      ]),
                    acc
                  ];
          } else {
            return acc;
          }
        } else {
          _acc = /* :: */[
            /* Move */Block.__(0, [
                x_init,
                y_init,
                x2,
                y2
              ]),
            acc
          ];
          _num = num - 1 | 0;
          _y = y2;
          _x = x2;
          continue ;
        }
      } else {
        return acc;
      }
    }
  };
}

function explore_directions(pos, x, y, lst, num) {
  return List.flatten(List.map((function (direction) {
                    return explore_direction(pos, x, y, x, y, direction[0], direction[1], num, /* [] */0);
                  }), lst));
}

function checked_direction(pos, t, pt_list, _x, _y, dx, dy, _num) {
  while(true) {
    var num = _num;
    var y = _y;
    var x = _x;
    if (num < 1) {
      return false;
    } else {
      var match = add(/* tuple */[
            x,
            y
          ], /* tuple */[
            dx,
            dy
          ]);
      var y2 = match[1];
      var x2 = match[0];
      if (within_range2(/* tuple */[
              x2,
              y2
            ])) {
        var match$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x2), y2);
        if (match$1) {
          var match$2 = match$1[0];
          if (match$2[1] !== t) {
            return List.mem(match$2[0], pt_list);
          } else {
            return false;
          }
        } else {
          _num = num - 1 | 0;
          _y = y2;
          _x = x2;
          continue ;
        }
      } else {
        return false;
      }
    }
  };
}

function checked_directions(pos, c, pt_list, x, y, _lst, num) {
  while(true) {
    var lst = _lst;
    if (lst) {
      var match = lst[0];
      if (checked_direction(pos, c, pt_list, x, y, match[0], match[1], num)) {
        return true;
      } else {
        _lst = lst[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function checked(pos, t, x, y) {
  if (checked_directions(pos, t, /* :: */[
          /* Rook */2,
          /* :: */[
            /* Queen */1,
            /* [] */0
          ]
        ], x, y, rook, 10) || checked_directions(pos, t, /* :: */[
          /* Bishop */3,
          /* :: */[
            /* Queen */1,
            /* [] */0
          ]
        ], x, y, bishop, 10) || checked_directions(pos, t, /* :: */[
          /* Knight */4,
          /* [] */0
        ], x, y, knight, 1) || checked_directions(pos, t, /* :: */[
          /* King */0,
          /* [] */0
        ], x, y, queen, 1)) {
    return true;
  } else {
    var tmp = t === /* White */1 ? pawn_white_cap : pawn_black_cap;
    return checked_directions(pos, t, /* :: */[
                /* Pawn */5,
                /* [] */0
              ], x, y, tmp, 1);
  }
}

function find_king(pos, c) {
  return c ? pos[/* king_w */7] : pos[/* king_b */8];
}

function king_checked(pos, c) {
  var match = find_king(pos, c);
  if (match !== undefined) {
    var match$1 = match;
    return checked(pos, c, match$1[0], match$1[1]);
  } else {
    return false;
  }
}

function empty_segment(pos, row, _x, y) {
  while(true) {
    var x = _x;
    if (x > y) {
      return true;
    } else if (Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), row) !== /* Empty */0) {
      return false;
    } else {
      _x = x + 1 | 0;
      continue ;
    }
  };
}

function check_castle(pos, still_can, row, next, last, rk) {
  if (still_can && Caml_obj.caml_equal(Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], rk), row), /* Piece */[/* tuple */[
            /* Rook */2,
            pos[/* turn */1]
          ]]) && empty_segment(pos, row, next < last ? next : last, next > last ? next : last) && !checked(pos, pos[/* turn */1], 4, row)) {
    var a = copy_matrix(pos[/* ar */0]);
    Caml_array.caml_array_set(Caml_array.caml_array_get(a, 4), row, /* Empty */0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(a, next), row, /* Piece */[/* tuple */[
            /* King */0,
            pos[/* turn */1]
          ]]);
    return !checked(/* record */[
                /* ar */a,
                /* turn */pos[/* turn */1],
                /* cas_w */pos[/* cas_w */2],
                /* cas_b */pos[/* cas_b */3],
                /* en_passant */pos[/* en_passant */4],
                /* prev */pos[/* prev */5],
                /* irr_change */pos[/* irr_change */6],
                /* king_w */pos[/* king_w */7],
                /* king_b */pos[/* king_b */8],
                /* number */pos[/* number */9],
                /* eval */pos[/* eval */10]
              ], pos[/* turn */1], next, row);
  } else {
    return false;
  }
}

function castle_moves(pos) {
  var match = pos[/* turn */1];
  var match$1 = match ? /* tuple */[
      pos[/* cas_w */2],
      0
    ] : /* tuple */[
      pos[/* cas_b */3],
      7
    ];
  var row = match$1[1];
  var match$2 = match$1[0];
  return Pervasives.$at(check_castle(pos, match$2[0], row, 3, 1, 0) ? /* :: */[
                /* Queenside_castle */1,
                /* [] */0
              ] : /* [] */0, check_castle(pos, match$2[1], row, 5, 6, 7) ? /* :: */[
                /* Kingside_castle */0,
                /* [] */0
              ] : /* [] */0);
}

function possible_field_simple_moves(pos, x, y) {
  var exp1 = function (lst) {
    return explore_directions(pos, x, y, lst, 1);
  };
  var expn = function (lst) {
    return explore_directions(pos, x, y, lst, 10);
  };
  var match = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), y);
  if (match) {
    var match$1 = match[0];
    var t = match$1[1];
    if (t === pos[/* turn */1]) {
      switch (match$1[0]) {
        case 0 : 
            return Pervasives.$at(castle_moves(pos), exp1(queen));
        case 1 : 
            return expn(queen);
        case 2 : 
            return expn(rook);
        case 3 : 
            return expn(bishop);
        case 4 : 
            return exp1(knight);
        case 5 : 
            var y2 = t ? y + 1 | 0 : y - 1 | 0;
            var tmp = /* record */[/* contents : [] */0];
            var also = function (some_move) {
              tmp[0] = /* :: */[
                some_move,
                tmp[0]
              ];
              return /* () */0;
            };
            var officers = /* :: */[
              /* Bishop */3,
              /* :: */[
                /* Knight */4,
                /* :: */[
                  /* Rook */2,
                  /* :: */[
                    /* Queen */1,
                    /* [] */0
                  ]
                ]
              ]
            ];
            if (y2 === 7 && t === /* White */1 || y2 === 0 && t === /* Black */0) {
              var match$2 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), y2);
              if (!match$2) {
                List.iter((function (pt) {
                        return also(/* Promotion */Block.__(1, [
                                      pt,
                                      x,
                                      x
                                    ]));
                      }), officers);
              }
              List.iter((function (x2) {
                      if (within_range(x2)) {
                        var match = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x2), y2);
                        if (match && match[0][1] !== t) {
                          return List.iter((function (pt) {
                                        return also(/* Promotion */Block.__(1, [
                                                      pt,
                                                      x,
                                                      x2
                                                    ]));
                                      }), officers);
                        } else {
                          return /* () */0;
                        }
                      } else {
                        return 0;
                      }
                    }), /* :: */[
                    x - 1 | 0,
                    /* :: */[
                      x + 1 | 0,
                      /* [] */0
                    ]
                  ]);
            } else {
              var match$3 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), y2);
              if (!match$3) {
                also(/* Move */Block.__(0, [
                        x,
                        y,
                        x,
                        y2
                      ]));
              }
              List.iter((function (x2) {
                      if (within_range(x2)) {
                        var match = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x2), y2);
                        if (match && match[0][1] !== t) {
                          return also(/* Move */Block.__(0, [
                                        x,
                                        y,
                                        x2,
                                        y2
                                      ]));
                        } else {
                          return /* () */0;
                        }
                      } else {
                        return 0;
                      }
                    }), /* :: */[
                    x - 1 | 0,
                    /* :: */[
                      x + 1 | 0,
                      /* [] */0
                    ]
                  ]);
            }
            if (y !== 1) {
              if (y === 6) {
                if (!t) {
                  var match$4 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), 5);
                  var match$5 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), 4);
                  if (!match$4) {
                    if (match$5) {
                      
                    } else {
                      also(/* Move */Block.__(0, [
                              x,
                              y,
                              x,
                              4
                            ]));
                    }
                  }
                  
                }
                
              }
              
            } else if (t) {
              var match$6 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), 2);
              var match$7 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), 3);
              if (!match$6) {
                if (match$7) {
                  
                } else {
                  also(/* Move */Block.__(0, [
                          x,
                          y,
                          x,
                          3
                        ]));
                }
              }
              
            }
            var match$8 = pos[/* en_passant */4];
            if (match$8 !== undefined) {
              var i = match$8;
              var y_en_passant = t ? 5 : 2;
              List.iter((function (x2) {
                      if (within_range(x2) && x2 === i && y2 === y_en_passant) {
                        return also(/* Move */Block.__(0, [
                                      x,
                                      y,
                                      x2,
                                      y2
                                    ]));
                      } else {
                        return 0;
                      }
                    }), /* :: */[
                    x - 1 | 0,
                    /* :: */[
                      x + 1 | 0,
                      /* [] */0
                    ]
                  ]);
            }
            return tmp[0];
        
      }
    } else {
      return /* [] */0;
    }
  } else {
    return /* [] */0;
  }
}

function possible_moves(pos) {
  var tmp = /* [] */0;
  for(var x = 0; x <= 7; ++x){
    for(var y = 0; y <= 7; ++y){
      tmp = Pervasives.$at(possible_field_simple_moves(pos, x, y), tmp);
    }
  }
  return tmp;
}

var board_center = /* array */[
  /* array */[
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  /* array */[
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  /* array */[
    0,
    0,
    3,
    5,
    5,
    3,
    0,
    0
  ],
  /* array */[
    0,
    0,
    5,
    9,
    9,
    5,
    0,
    0
  ],
  /* array */[
    0,
    0,
    5,
    9,
    9,
    5,
    0,
    0
  ],
  /* array */[
    0,
    0,
    3,
    5,
    5,
    3,
    0,
    0
  ],
  /* array */[
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  /* array */[
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]
];

function mirror_y(c, y) {
  if (c) {
    return y;
  } else {
    return 7 - y | 0;
  }
}

function piece_value(pt, x, y, c) {
  var y$1 = mirror_y(c, y);
  var tmp;
  switch (pt) {
    case 0 : 
        tmp = 1000000 - Caml_int32.imul(5, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    case 1 : 
        tmp = 9000 + Caml_int32.imul(10, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    case 2 : 
        tmp = 5000 + Caml_int32.imul(10, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    case 3 : 
        tmp = 3200 + Caml_int32.imul(20, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    case 4 : 
        tmp = 3000 + Caml_int32.imul(30, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    case 5 : 
        tmp = 1000 + Caml_int32.imul(30, Caml_array.caml_array_get(Caml_array.caml_array_get(board_center, x), y$1)) | 0;
        break;
    
  }
  return tmp + Caml_int32.imul(5, y$1) | 0;
}

function field_value(pos, x, y) {
  var match = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x), y);
  if (match) {
    var match$1 = match[0];
    return piece_value(match$1[0], x, y, match$1[1]);
  } else {
    return 0;
  }
}

var win = piece_value(/* King */0, 0, 0, /* White */1) / 2 | 0;

function delta(pos, mv) {
  if (Pervasives.abs(pos[/* eval */10]) >= win) {
    return 0;
  } else if (typeof mv === "number") {
    if (mv === 0) {
      return 500;
    } else {
      return 400;
    }
  } else if (mv.tag) {
    var x2 = mv[2];
    var match = pos[/* turn */1];
    var match$1 = match ? /* tuple */[
        6,
        7
      ] : /* tuple */[
        1,
        0
      ];
    var y2 = match$1[1];
    return (piece_value(mv[0], x2, y2, pos[/* turn */1]) - piece_value(/* Pawn */5, mv[1], match$1[0], pos[/* turn */1]) | 0) + field_value(pos, x2, y2) | 0;
  } else {
    var y2$1 = mv[3];
    var x2$1 = mv[2];
    var y1 = mv[1];
    var x1 = mv[0];
    var match$2 = Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], x1), y1);
    if (match$2) {
      var match$3 = match$2[0];
      var c = match$3[1];
      var pt = match$3[0];
      return (piece_value(pt, x2$1, y2$1, c) - piece_value(pt, x1, y1, c) | 0) + field_value(pos, x2$1, y2$1) | 0;
    } else {
      throw Illegal_move;
    }
  }
}

var Interrupt = Caml_exceptions.create("Ochess.Interrupt");

var deadline = /* record */[/* contents */undefined];

function check_timer() {
  var match = deadline[0];
  if (match !== undefined && Caml_sys.caml_sys_time(/* () */0) > match) {
    throw Interrupt;
  } else {
    return 0;
  }
}

function set_timer(interval) {
  deadline[0] = Caml_sys.caml_sys_time(/* () */0) + interval;
  return /* () */0;
}

function del_timer() {
  deadline[0] = undefined;
  return /* () */0;
}

var Illegal_position = Caml_exceptions.create("Ochess.Illegal_position");

function alpha_beta(pos, depth, achievable, cutoff) {
  check_timer(/* () */0);
  var pm = List.map((function (m) {
          return /* tuple */[
                  delta(pos, m),
                  m
                ];
        }), possible_moves(pos));
  var pm$1 = List.sort((function (param, param$1) {
          return Caml_primitive.caml_int_compare(param$1[0], param[0]);
        }), pm);
  if (pm$1) {
    if (pm$1[0][0] >= win) {
      throw Illegal_position;
    }
    
  }
  var loop = function (ach, cut, _lst, best) {
    while(true) {
      var lst = _lst;
      if (ach >= cut || !lst) {
        return /* tuple */[
                ach,
                best
              ];
      } else {
        var tl = lst[1];
        var match = lst[0];
        var m = match[1];
        try {
          var p_new = make_move(pos, m, match[0]);
          var v = draw(p_new) ? 0 : -alpha_beta(p_new, depth - 1 | 0, -cut | 0, -ach | 0)[0] | 0;
          if (v > ach) {
            return loop(v, cut, tl, /* Good */[m]);
          } else {
            return loop(ach, cut, tl, typeof best === "number" && best !== 0 ? /* Bad_moves */0 : best);
          }
        }
        catch (exn){
          if (exn === Illegal_position) {
            _lst = tl;
            continue ;
          } else {
            throw exn;
          }
        }
      }
    };
  };
  var prelim;
  if (pm$1) {
    var match = pm$1[0];
    prelim = depth <= 1 ? /* tuple */[
        (-pos[/* eval */10] | 0) + match[0] | 0,
        /* Good */[match[1]]
      ] : loop(achievable, cutoff, pm$1, /* No_moves */1);
  } else {
    prelim = /* tuple */[
      0,
      /* No_moves */1
    ];
  }
  var match$1 = prelim[1];
  var v = prelim[0];
  if (typeof match$1 === "number") {
    if (match$1 !== 0) {
      if (king_checked(pos, pos[/* turn */1])) {
        return /* tuple */[
                -win | 0,
                undefined
              ];
      } else {
        return /* tuple */[
                0,
                undefined
              ];
      }
    } else {
      return /* tuple */[
              v,
              undefined
            ];
    }
  } else {
    return /* tuple */[
            v,
            match$1[0]
          ];
  }
}

function alpha_beta_search(pos, depth) {
  return alpha_beta(pos, depth, Caml_int32.imul(-100, win), Caml_int32.imul(100, win));
}

function legal_moves(pos) {
  return List.filter((function (m) {
                  var p_new = make_move(pos, m, 0);
                  return !king_checked(p_new, pos[/* turn */1]);
                }))(possible_moves(pos));
}

function alpha_beta_deepening(pos, interval) {
  deadline[0] = undefined;
  var current_best = /* record */[/* contents */alpha_beta_search(pos, 2)];
  try {
    Sys.set_signal(Sys.sigint, /* Signal_handle */[(function () {
              throw Interrupt;
            })]);
    set_timer(interval);
    var loop = function (_i) {
      while(true) {
        var i = _i;
        if (i > 10) {
          return /* () */0;
        } else {
          var tmp = alpha_beta_search(pos, i);
          current_best[0] = tmp;
          if (tmp[0] >= win || tmp[0] <= (-win | 0)) {
            return /* () */0;
          } else {
            _i = i + 1 | 0;
            continue ;
          }
        }
      };
    };
    loop(3);
    Sys.set_signal(Sys.sigint, /* Signal_ignore */1);
    deadline[0] = undefined;
  }
  catch (exn){
    if (exn !== Interrupt) {
      throw exn;
    }
    
  }
  Sys.set_signal(Sys.sigint, /* Signal_ignore */1);
  deadline[0] = undefined;
  return current_best[0];
}

function previous(pos) {
  var match = pos[/* prev */5];
  if (match !== undefined) {
    return match;
  } else {
    return pos;
  }
}

function print_move(p, param) {
  if (typeof param === "number") {
    if (param === 0) {
      return Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "O-O",
                      /* End_of_format */0
                    ]),
                  "O-O"
                ]);
    } else {
      return Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "O-O-O",
                      /* End_of_format */0
                    ]),
                  "O-O-O"
                ]);
    }
  } else if (param.tag) {
    var match = p[/* turn */1];
    var match$1 = match ? /* tuple */[
        6,
        7
      ] : /* tuple */[
        1,
        0
      ];
    return Curry._5(Printf.printf(/* Format */[
                    /* Char */Block.__(0, [/* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char */Block.__(0, [/* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* Char */Block.__(0, [/* End_of_format */0])
                                  ])])
                          ])]),
                    "%c%d%c%d%c"
                  ]), Caml_string.get("abcdefgh", param[1]), match$1[0] + 1 | 0, Caml_string.get("abcdefgh", param[2]), match$1[1] + 1 | 0, Char.lowercase(List.assoc(param[0], piece_chars)));
  } else {
    var y1 = param[1];
    var x1 = param[0];
    var match$2 = Caml_array.caml_array_get(Caml_array.caml_array_get(p[/* ar */0], x1), y1);
    if (match$2) {
      return Curry._4(Printf.printf(/* Format */[
                      /* Char */Block.__(0, [/* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char */Block.__(0, [/* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])])
                            ])]),
                      "%c%d%c%d"
                    ]), Caml_string.get("abcdefgh", x1), y1 + 1 | 0, Caml_string.get("abcdefgh", param[2]), param[3] + 1 | 0);
    } else {
      throw Illegal_move;
    }
  }
}

function is_digit(c) {
  if (/* "0" */48 <= c) {
    return c <= /* "9" */57;
  } else {
    return false;
  }
}

function int_of_char(c) {
  return (c - /* "0" */48 | 0) - 1 | 0;
}

function parse_move_string(str) {
  try {
    var tmp;
    switch (str) {
      case "O-O" : 
          tmp = /* Kingside_castle */0;
          break;
      case "O-O-O" : 
          tmp = /* Queenside_castle */1;
          break;
      default:
        var match = str.length;
        if (match !== 4) {
          if (match !== 5) {
            throw Pervasives.Exit;
          } else if (is_digit(Caml_string.get(str, 1)) && is_digit(Caml_string.get(str, 3))) {
            tmp = /* Promotion */Block.__(1, [
                rassoc(Char.uppercase(Caml_string.get(str, 4)), piece_chars),
                int_of_letter(Caml_string.get(str, 0)),
                int_of_letter(Caml_string.get(str, 2))
              ]);
          } else {
            throw Pervasives.Exit;
          }
        } else {
          tmp = /* Move */Block.__(0, [
              int_of_letter(Caml_string.get(str, 0)),
              int_of_char(Caml_string.get(str, 1)),
              int_of_letter(Caml_string.get(str, 2)),
              int_of_char(Caml_string.get(str, 3))
            ]);
        }
    }
    return tmp;
  }
  catch (exn){
    return undefined;
  }
}

function parse_move(pos, str) {
  var v = parse_move_string(str);
  if (v !== undefined) {
    var match = v;
    if (typeof match === "number" || match.tag || match[0] !== 4) {
      return v;
    } else {
      var match$1 = match[1];
      if (match$1 !== 0) {
        if (match$1 !== 7) {
          return v;
        } else {
          var match$2 = match[2];
          if (match$2 !== 2) {
            if (match$2 !== 6 || match[3] !== 7 || !Caml_obj.caml_equal(Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], 4), 7), /* Piece */[/* tuple */[
                      /* King */0,
                      /* Black */0
                    ]])) {
              return v;
            } else {
              return /* Kingside_castle */0;
            }
          } else if (match[3] !== 7 || !Caml_obj.caml_equal(Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], 4), 7), /* Piece */[/* tuple */[
                    /* King */0,
                    /* Black */0
                  ]])) {
            return v;
          } else {
            return /* Queenside_castle */1;
          }
        }
      } else {
        var match$3 = match[2];
        if (match$3 !== 2) {
          if (match$3 !== 6 || match[3] !== 0 || !Caml_obj.caml_equal(Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], 4), 0), /* Piece */[/* tuple */[
                    /* King */0,
                    /* White */1
                  ]])) {
            return v;
          } else {
            return /* Kingside_castle */0;
          }
        } else if (match[3] !== 0 || !Caml_obj.caml_equal(Caml_array.caml_array_get(Caml_array.caml_array_get(pos[/* ar */0], 4), 0), /* Piece */[/* tuple */[
                  /* King */0,
                  /* White */1
                ]])) {
          return v;
        } else {
          return /* Queenside_castle */1;
        }
      }
    }
  } else {
    return v;
  }
}

function game_status(pos) {
  if (draw(pos)) {
    return /* Draw */0;
  } else {
    var lm = legal_moves(pos);
    if (lm) {
      return /* Play */Block.__(1, [lm]);
    } else if (king_checked(pos, pos[/* turn */1])) {
      return /* Win */Block.__(0, [pos[/* turn */1] ? /* Black */0 : /* White */1]);
    } else {
      return /* Draw */0;
    }
  }
}

function best_move(pos, interval) {
  var match = legal_moves(pos);
  if (match && !match[1]) {
    return match[0];
  } else {
    return alpha_beta_deepening(pos, interval)[1];
  }
}

function init_rem_time(param) {
  switch (param.tag | 0) {
    case 0 : 
        return param[1];
    case 1 : 
    case 2 : 
        return param[0];
    
  }
}

function thinking_interval(moves_made, cl, remaining) {
  switch (cl.tag | 0) {
    case 0 : 
        var n = cl[0];
        var moves_until_incr = (n - Caml_int32.mod_(moves_made, n) | 0) + 1 | 0;
        var est_moves_to_play = Caml_primitive.caml_int_max(20, 50 - moves_made | 0);
        var rem_moves = moves_until_incr < est_moves_to_play ? moves_until_incr : est_moves_to_play;
        return 0.95 * remaining / (rem_moves + 2 | 0);
    case 1 : 
        var est_moves_to_play$1 = Caml_primitive.caml_int_max(20, 50 - moves_made | 0);
        return 0.95 * Caml_primitive.caml_float_min(remaining, remaining / est_moves_to_play$1 + cl[1]);
    case 2 : 
        return 0.95 * cl[0];
    
  }
}

function update_remaining(_, cl, remaining, interval) {
  switch (cl.tag | 0) {
    case 0 : 
        return remaining - interval;
    case 1 : 
        return cl[0] + cl[1] - interval;
    case 2 : 
        return cl[0];
    
  }
}

function parse_time(str) {
  var match = split_on_char(/* ":" */58, str);
  if (match) {
    var match$1 = match[1];
    var x = match[0];
    if (match$1) {
      if (match$1[1]) {
        throw Pervasives.Exit;
      } else {
        return 60.0 * Caml_format.caml_float_of_string(x) + Caml_format.caml_float_of_string(match$1[0]);
      }
    } else {
      return 60.0 * Caml_format.caml_float_of_string(x);
    }
  } else {
    throw Pervasives.Exit;
  }
}

function flush() {
  return Pervasives.flush(Pervasives.stdout);
}

function parse_level(a1, a2, a3) {
  var a1$1 = Caml_format.caml_int_of_string(a1);
  var a2$1 = parse_time(a2);
  var a3$1 = Caml_format.caml_float_of_string(a3);
  if (a1$1 <= 0) {
    return /* Incremental */Block.__(1, [
              a2$1,
              a3$1
            ]);
  } else {
    return /* Conventional */Block.__(0, [
              a1$1,
              a2$1
            ]);
  }
}

function main() {
  Sys.set_signal(Sys.sigint, /* Signal_ignore */1);
  Printf.printf(/* Format */[
        /* String_literal */Block.__(11, [
            " Ctrl-C is bound to \"move now!\". Use Ctrl-D to quit\n",
            /* End_of_format */0
          ]),
        " Ctrl-C is bound to \"move now!\". Use Ctrl-D to quit\n"
      ]);
  var x0_002 = /* cl : Exact */Block.__(2, [3.0]);
  var x0 = /* record */[
    /* pos */init_position,
    /* c : Black */0,
    x0_002,
    /* rem_time */30000.0,
    /* gui */false
  ];
  var think = function (_x) {
    while(true) {
      var x = _x;
      if (!x[/* gui */4]) {
        print_position(x[/* pos */0]);
        Pervasives.flush(Pervasives.stdout);
      }
      var game_over = (function(x){
      return function game_over(msg) {
        Pervasives.print_string(msg);
        Pervasives.flush(Pervasives.stdout);
        return interact(x, /* [] */0);
      }
      }(x));
      var match = game_status(x[/* pos */0]);
      if (typeof match === "number") {
        return game_over("1/2-1/2 {Draw}\n");
      } else if (match.tag) {
        var lm = match[0];
        if (lm === /* [] */0) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "ochess.ml",
                  677,
                  7
                ]
              ];
        }
        if (x[/* c */1] === x[/* pos */0][/* turn */1]) {
          var interval = thinking_interval(x[/* pos */0][/* number */9] / 2 | 0, x[/* cl */2], x[/* rem_time */3]);
          var match$1 = best_move(x[/* pos */0], interval);
          if (match$1 !== undefined) {
            var mv = match$1;
            if (!List.mem(mv, lm)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "ochess.ml",
                      682,
                      14
                    ]
                  ];
            }
            Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "move ",
                      /* End_of_format */0
                    ]),
                  "move "
                ]);
            print_move(x[/* pos */0], mv);
            Pervasives.print_newline(/* () */0);
            Pervasives.flush(Pervasives.stdout);
            var pos_new = make_move(x[/* pos */0], mv, delta(x[/* pos */0], mv));
            _x = /* record */[
              /* pos */pos_new,
              /* c */x[/* c */1],
              /* cl */x[/* cl */2],
              /* rem_time */update_remaining(x[/* pos */0][/* number */9] / 2 | 0, x[/* cl */2], x[/* rem_time */3], interval),
              /* gui */x[/* gui */4]
            ];
            continue ;
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "ochess.ml",
                    681,
                    54
                  ]
                ];
          }
        } else {
          return interact(x, lm);
        }
      } else if (match[0]) {
        return game_over("1-0 {White wins}\n");
      } else {
        return game_over("0-1 {Black wins}\n");
      }
    };
  };
  var interact = function (x, lst) {
    var str = Pervasives.read_line(/* () */0);
    var ignoring = function (str) {
      Curry._1(Printf.printf(/* Format */[
                /* String_literal */Block.__(11, [
                    " Ignoring command ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "\n" */10,
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                " Ignoring command %s\n"
              ]), str);
      Pervasives.flush(Pervasives.stdout);
      return think(x);
    };
    var match = split_on_char(/* " " */32, str);
    var exit = 0;
    if (match) {
      var exit$1 = 0;
      switch (match[0]) {
        case "black" : 
            if (match[1]) {
              exit = 1;
            } else {
              return think(/* record */[
                          /* pos */x[/* pos */0],
                          /* c : Black */0,
                          /* cl */x[/* cl */2],
                          /* rem_time */x[/* rem_time */3],
                          /* gui */x[/* gui */4]
                        ]);
            }
            break;
        case "level" : 
            var match$1 = match[1];
            if (match$1) {
              var match$2 = match$1[1];
              if (match$2) {
                var match$3 = match$2[1];
                if (match$3 && !match$3[1]) {
                  try {
                    var tmp = parse_level(match$1[0], match$2[0], match$3[0]);
                    return think(/* record */[
                                /* pos */x[/* pos */0],
                                /* c */x[/* c */1],
                                /* cl */tmp,
                                /* rem_time */init_rem_time(tmp),
                                /* gui */x[/* gui */4]
                              ]);
                  }
                  catch (exn){
                    return think(x);
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            break;
        case "new" : 
            if (match[1]) {
              exit = 1;
            } else {
              return think(/* record */[
                          /* pos */init_position,
                          /* c : Black */0,
                          /* cl : Exact */Block.__(2, [3.0]),
                          /* rem_time */30000.0,
                          /* gui */x[/* gui */4]
                        ]);
            }
            break;
        case "otim" : 
            var match$4 = match[1];
            if (match$4 && !match$4[1]) {
              return think(x);
            } else {
              exit = 1;
            }
            break;
        case "quit" : 
            if (match[1]) {
              exit = 1;
            } else {
              throw Pervasives.Exit;
            }
            break;
        case "?" : 
        case "draw" : 
        case "easy" : 
        case "force" : 
        case "hard" : 
        case "random" : 
            exit$1 = 2;
            break;
        case "remove" : 
            if (match[1]) {
              exit = 1;
            } else {
              return think(/* record */[
                          /* pos */previous(previous(x[/* pos */0])),
                          /* c */x[/* c */1],
                          /* cl */x[/* cl */2],
                          /* rem_time */x[/* rem_time */3],
                          /* gui */x[/* gui */4]
                        ]);
            }
            break;
        case "result" : 
            return think(x);
        case "st" : 
            var match$5 = match[1];
            if (match$5 && !match$5[1]) {
              try {
                var tmp$1 = /* Exact */Block.__(2, [Caml_format.caml_float_of_string(match$5[0])]);
                return think(/* record */[
                            /* pos */x[/* pos */0],
                            /* c */x[/* c */1],
                            /* cl */tmp$1,
                            /* rem_time */init_rem_time(tmp$1),
                            /* gui */x[/* gui */4]
                          ]);
              }
              catch (exn$1){
                return think(x);
              }
            } else {
              exit = 1;
            }
            break;
        case "time" : 
            var match$6 = match[1];
            if (match$6 && !match$6[1]) {
              try {
                return think(/* record */[
                            /* pos */x[/* pos */0],
                            /* c */x[/* c */1],
                            /* cl */x[/* cl */2],
                            /* rem_time */Caml_format.caml_float_of_string(match$6[0]) / 100.0,
                            /* gui */x[/* gui */4]
                          ]);
              }
              catch (exn$2){
                return ignoring(str);
              }
            } else {
              exit = 1;
            }
            break;
        case "white" : 
            if (match[1]) {
              exit = 1;
            } else {
              return think(/* record */[
                          /* pos */x[/* pos */0],
                          /* c : White */1,
                          /* cl */x[/* cl */2],
                          /* rem_time */x[/* rem_time */3],
                          /* gui */x[/* gui */4]
                        ]);
            }
            break;
        case "xboard" : 
            if (match[1]) {
              exit = 1;
            } else {
              Printf.printf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "feature myname=\"O'Chess\" done=1\n",
                        /* End_of_format */0
                      ]),
                    "feature myname=\"O'Chess\" done=1\n"
                  ]);
              Pervasives.flush(Pervasives.stdout);
              return think(/* record */[
                          /* pos */x[/* pos */0],
                          /* c */x[/* c */1],
                          /* cl */x[/* cl */2],
                          /* rem_time */x[/* rem_time */3],
                          /* gui */true
                        ]);
            }
            break;
        default:
          exit = 1;
      }
      if (exit$1 === 2) {
        if (match[1]) {
          exit = 1;
        } else {
          return think(x);
        }
      }
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$7 = parse_move(x[/* pos */0], str);
      if (match$7 !== undefined) {
        var mv = match$7;
        if (List.mem(mv, lst)) {
          var pos_new = make_move(x[/* pos */0], mv, delta(x[/* pos */0], mv));
          return think(/* record */[
                      /* pos */pos_new,
                      /* c */x[/* c */1],
                      /* cl */x[/* cl */2],
                      /* rem_time */x[/* rem_time */3],
                      /* gui */x[/* gui */4]
                    ]);
        } else {
          Curry._1(Printf.printf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "Illegal move: ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "\n" */10,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "Illegal move: %s\n"
                  ]), str);
          Pervasives.flush(Pervasives.stdout);
          return think(x);
        }
      } else {
        return ignoring(str);
      }
    }
    
  };
  try {
    return think(x0);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.end_of_file || exn === Pervasives.Exit) {
      return Pervasives.flush(Pervasives.stdout);
    } else {
      throw exn;
    }
  }
}

var pawn_white_mv = /* :: */[
  /* tuple */[
    0,
    1
  ],
  /* [] */0
];

var pawn_black_mv = /* :: */[
  /* tuple */[
    0,
    -1
  ],
  /* [] */0
];

var max_depth = 10;

export {
  split_on_char ,
  identical_positions ,
  draw_by_repetition_aux ,
  draw_by_repetition ,
  draw_by_lack_of_progress ,
  draw ,
  opposite_color ,
  color_sign ,
  piece_chars ,
  char_of_piece_type ,
  rassoc ,
  piece_type_of_char ,
  int_of_letter ,
  letter_of_int ,
  print_board ,
  print_position ,
  init_position ,
  within_range ,
  within_range2 ,
  copy_matrix ,
  no_k_castle ,
  no_q_castle ,
  Illegal_move ,
  make_move ,
  knight ,
  rook ,
  bishop ,
  queen ,
  pawn_white_mv ,
  pawn_black_mv ,
  pawn_white_cap ,
  pawn_black_cap ,
  add ,
  explore_direction ,
  explore_directions ,
  checked_direction ,
  checked_directions ,
  checked ,
  find_king ,
  king_checked ,
  empty_segment ,
  check_castle ,
  castle_moves ,
  possible_field_simple_moves ,
  possible_moves ,
  board_center ,
  mirror_y ,
  piece_value ,
  field_value ,
  win ,
  delta ,
  Interrupt ,
  deadline ,
  check_timer ,
  set_timer ,
  del_timer ,
  Illegal_position ,
  alpha_beta ,
  alpha_beta_search ,
  legal_moves ,
  max_depth ,
  alpha_beta_deepening ,
  previous ,
  print_move ,
  is_digit ,
  int_of_char ,
  parse_move_string ,
  parse_move ,
  game_status ,
  best_move ,
  init_rem_time ,
  thinking_interval ,
  update_remaining ,
  parse_time ,
  flush ,
  parse_level ,
  main ,
  
}
/* init_array Not a pure module */
